<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Edit Event - Church Planner</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="stylenew.css">
  <link rel="stylesheet" href="view.css">
</head>
<script src="auth.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
    // Check authentication
    if (!AuthService.isAuthenticated()) {
        window.location.href = 'login.html';
        return;
    }

    // Check if user has planner role
    if (!AuthService.hasRole('planner')) {
        showError("You don't have permission to edit events");
        window.location.href = 'index.html';
        return;
    }

    // Display current user info
    const user = AuthService.getCurrentUser();
    if (user && document.getElementById('userName')) {
        document.getElementById('userName').textContent = user.name || user.email;
    }

    // Set up logout button
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
            AuthService.logout();
        });
    }

    loadEventAndBulletins();
});
</script>
<body>
  <div class="dashboard">
        <!-- Mobile Menu Toggle -->
        <button class="menu-toggle" id="menuToggle">
            <i class="fas fa-bars"></i>
        </button>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <h2><i class="fas fa-clock"></i> Event Scheduler </h2>
    </div>
    <div class="nav-menu">
        <div class="nav-item">
            <a href="index.html" class="nav-link">
                <i class="fas fa-home"></i> Live Dashboard
            </a>
        </div>
        <div class="nav-item">
            <a href="start_planning.html" class="nav-link">
                <i class="fas fa-calendar-plus"></i> Schedule Event
            </a>
        </div>
        <div class="nav-item">
            <a href="view_plans.html" class="nav-link">
                <i class="fas fa-calendar-alt"></i> View Events
            </a>
        </div>
        <div class="nav-item">
            <a href="templates.html" class="nav-link">
                <i class="fas fa-clone"></i> Event Templates
            </a>
        </div>
        <div class="nav-item">
            <a href="reports.html" class="nav-link">
                <i class="fas fa-chart-bar"></i> Analytics & Reports
            </a>
        </div>
        <div class="nav-item">
            <a href="admin.html" class="nav-link">
                <i class="fas fa-users-cog"></i> User Management
            </a>
        </div>
    </div>
</div>

    <!-- Main Content -->
    <div class="main-content">
      <div class="header">
        <h1><i class="fas fa-edit"></i> Edit Event & Bulletin</h1>
        <div class="user-info">
          <div class="user-avatar" id="userAvatar">AD</div>
          <button class="logout-btn" id="logoutBtn">
            <i class="fas fa-sign-out-alt"></i> <span>Logout</span>
          </button>
        </div>
      </div>

      <div id="message"></div>

      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-info-circle"></i> Event Details</h2>
        </div>
        <div class="form-grid">
          <div class="form-group">
            <label for="eventTitle"><i class="fas fa-heading"></i> Event Title</label>
            <input type="text" id="eventTitle" class="form-control" required>
          </div>
          <div class="form-group">
            <label for="eventDate"><i class="fas fa-calendar-day"></i> Event Date</label>
            <input type="date" id="eventDate" class="form-control" required>
          </div>
          <div class="form-group">
            <label for="startTime"><i class="fas fa-clock"></i> Start Time</label>
            <input type="time" id="startTime" class="form-control" required>
          </div>
          <div class="form-group">
            <label for="location"><i class="fas fa-location-dot"></i> Location / Room</label>
            <input type="text" id="location" class="form-control" placeholder="e.g., Main Sanctuary, Youth Hall">
          </div>
          <div class="form-group">
            <label for="eventType"><i class="fas fa-tag"></i> Event Type</label>
            <select id="eventType" class="form-control" required></select>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-list-ul"></i> Bulletin Items</h2>
        </div>
        <div class="card-body">
          <button class="btn btn-success" onclick="addBulletinItem()">
            <i class="fas fa-plus"></i> Add Item
          </button>
          
          <div class="table-responsive">
            <table class="bulletin-item-table">
              <thead>
                <tr>
                  <th>Title</th>
                  <th>Duration (min)</th>
                  <th>Preacher</th>
                  <th>Language</th>
                  <th>Category</th>
                  <th>Order</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="bulletinTableBody"></tbody>
            </table>
          </div>
          
          <div style="margin-top: 20px;">
            <button class="btn btn-primary" onclick="submitEdit()">
              <i class="fas fa-save"></i> Save Changes
            </button>
            <button class="btn btn-secondary" onclick="window.history.back()">
              <i class="fas fa-arrow-left"></i> Cancel
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Conflict Modal -->
  <div id="conflictModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title"><i class="fas fa-exclamation-triangle"></i> Event Conflicts</h3>
        <button class="modal-close" onclick="document.getElementById('conflictModal').style.display='none'">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div id="conflictModalBody"></div>
      <div class="conflict-options">
        <button class="btn btn-danger" onclick="resolveConflict('keep_mine')">
          <i class="fas fa-trash"></i> Keep My Event (Delete Conflicting)
        </button>
        <button class="btn" onclick="resolveConflict('keep_other')">
          <i class="fas fa-ban"></i> Keep Conflicting Event (Cancel Mine)
        </button>
        <button class="btn" onclick="resolveConflict('change_mine')">
          <i class="fas fa-edit"></i> Change My Event Time
        </button>
        <button class="btn" onclick="resolveConflict('change_other')">
          <i class="fas fa-edit"></i> Change Conflicting Event Time
        </button>
      </div>
    </div>
  </div>

  <script>
    
    let eventId = null;
    let bulletins = [];
    let nextOrder = 1;

    async function apiCall(url, options = {}) {
    try {
        const response = await authFetch(url, {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || `HTTP ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('API Error:', error);
        // Redirect to login if token is missing/invalid
        if (error.message.includes('Token') || error.message.includes('auth')) {
            window.location.href = 'login.html';
        }
        throw error;
    }
}

    function showMessage(message, type = 'success') {
      const messageDiv = document.getElementById('message');
      const icon = type === 'success' ? 'fa-check-circle' : 
                  type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle';
      messageDiv.innerHTML = `
        <div class="alert alert-${type}">
          <i class="fas ${icon}"></i> ${message}
        </div>
      `;
      setTimeout(() => messageDiv.innerHTML = '', 5000);
    }
    function showError(message) { showMessage(message, 'error'); }

    function getUrlParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    function addBulletinItem() {
      bulletins.push({
        title: '',
        duration_minutes: 10,
        preacher: '',
        language: 'EN',
        category: '',
        display_order: nextOrder++
      });
      renderBulletinTable();
    }
    function deleteBulletinItem(index) {
      bulletins.splice(index, 1);
      renderBulletinTable();
    }
    function renderBulletinTable() {
      const tbody = document.getElementById("bulletinTableBody");
      tbody.innerHTML = "";
      bulletins.forEach((item, idx) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><input value="${item.title || ''}" onchange="updateItem(${idx}, 'title', this.value)" placeholder="Item title" /></td>
          <td><input type="number" value="${item.duration_minutes || 10}" onchange="updateItem(${idx}, 'duration_minutes', this.value)" min="1" /></td>
          <td><input value="${item.preacher || ''}" onchange="updateItem(${idx}, 'preacher', this.value)" placeholder="Preacher name" /></td>
          <td>
            <select onchange="updateItem(${idx}, 'language', this.value)">
              <option value="EN" ${item.language === 'EN' ? 'selected' : ''}>English</option>
              <option value="BEM" ${item.language === 'BEM' ? 'selected' : ''}>Bemba</option>
              <option value="NY" ${item.language === 'NY' ? 'selected' : ''}>Nyanja</option>
            </select>
          </td>
          <td><input value="${item.category || ''}" onchange="updateItem(${idx}, 'category', this.value)" placeholder="Category" /></td>
          <td><input type="number" value="${item.display_order || (idx + 1)}" onchange="updateItem(${idx}, 'display_order', this.value)" min="1" /></td>
          <td><button class="delete-btn" onclick="deleteBulletinItem(${idx})">Delete</button></td>
        `;
        tbody.appendChild(row);
      });
    }
    function updateItem(index, key, value) {
      if (bulletins[index]) {
        bulletins[index][key] = key === 'duration_minutes' || key === 'display_order' ? parseInt(value) : value;
      }
    }
    async function loadEventTypes(selectedId) {
    try {
        const types = await apiCall(`${API_BASE}/event_types`);
        const select = document.getElementById("eventType");
        select.innerHTML = '';
        types.forEach(t => {
            const opt = document.createElement("option");
            opt.value = t.id;
            opt.textContent = t.name;
            if (selectedId && t.id == selectedId) opt.selected = true;
            select.appendChild(opt);
        });
    } catch (error) {
        showError("Failed to load event types");
    }
}

async function loadEventAndBulletins() {
    eventId = getUrlParam('event_id');
    if (!eventId) {
        showError("No event ID provided.");
        document.querySelector('.bulletin-form').style.display = 'none';
        return;
    }
    try {
        const data = await apiCall(`${API_BASE}/events/${eventId}/edit`);
        document.getElementById('eventTitle').value = data.title;
        document.getElementById('eventDate').value = data.event_date;

        // Fix time format conversion
        let startTime = data.start_time;
        if (startTime) {
            // Handle cases where time might be "HH:MM:SS" or "H:MM:SS"
            const timeParts = startTime.split(':' );
            if (timeParts.length >= 2) {
                // Ensure two-digit hours and minutes
                const hours = timeParts[0].padStart(2, '0');
                const minutes = timeParts[1].padStart(2, '0');
                startTime = `${hours}:${minutes}`;
            }
        }
        document.getElementById('startTime').value = startTime || '';
        if (document.getElementById('location')) {
            document.getElementById('location').value = data.location || '';
        }

        await loadEventTypes(data.event_type_id);
        bulletins = data.bulletins.map((item, idx) => ({
            title: item.title || '',
            duration_minutes: item.duration_minutes || 10,
            preacher: item.preacher || '',
            language: item.language || 'EN',
            category: item.category || '',
            display_order: item.display_order || (idx + 1)
        }));
        nextOrder = bulletins.reduce((max, b) => Math.max(max, b.display_order), 0) + 1;
        renderBulletinTable();
    } catch (e) {
        showError("Failed to load event/bulletins.");
        console.error("Error loading event:", e);
    }
}

async function checkForConflicts(eventData) {
    try {
        // Create a temporary event object with the updated data
        const tempEvent = {
            event_date: eventData.event_date,
            start_time: eventData.start_time,
            end_time: eventData.end_time || "23:59:59", // Default end time if not provided
            location: eventData.location || null
        };
        
        // Check for conflicts using the server's conflict detection
        const response = await authFetch(`${API_BASE}/events/check-conflict`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                event_date: tempEvent.event_date,
                start_time: tempEvent.start_time,
                end_time: tempEvent.end_time,
                location: tempEvent.location,
                exclude_event_id: eventId
            })
        });
        
        if (!response.ok) {
            throw new Error("Failed to check for conflicts");
        }
        
        const result = await response.json();
        
        // Return conflicts if any
        if (result.has_conflict && result.conflicts && result.conflicts.length > 0) {
            return result.conflicts;
        }
        
        return [];
    } catch (error) {
        console.error("Error checking for conflicts:", error);
        return [];
    }
}

async function submitEdit() {
    if (!eventId) {
        showError("Event ID missing.");
        return;
    }
    
    const title = document.getElementById("eventTitle").value.trim();
    const eventDate = document.getElementById("eventDate").value;
    let startTime = document.getElementById("startTime").value;
    const eventTypeId = parseInt(document.getElementById("eventType").value);
    const location = (document.getElementById('location')?.value || '').trim() || null;

    if (!title || !eventDate || !startTime || !eventTypeId) {
        showError("Please fill all event fields.");
        return;
    }
    if (bulletins.length === 0) {
        showError("Please add at least one bulletin item.");
        return;
    }
    const invalidItems = bulletins.filter(item => !item.title || !item.duration_minutes);
    if (invalidItems.length > 0) {
        showError("Please fill in title and duration for all bulletin items.");
        return;
    }

    // Ensure startTime is in HH:MM:SS format for the server
    if (/^\d{2}:\d{2}$/.test(startTime)) {
        startTime += ":00";
    }
    
    // Calculate end time based on bulletins
    let totalDuration = 0;
    bulletins.forEach(item => {
        totalDuration += parseInt(item.duration_minutes) || 0;
    });
    
    // Calculate end time
    const startDateTime = new Date();
    startDateTime.setHours(parseInt(startTime.split(':')[0]), parseInt(startTime.split(':')[1]), 0);
    const endDateTime = new Date(startDateTime.getTime() + totalDuration * 60000);
    const endTime = `${endDateTime.getHours().toString().padStart(2, '0')}:${endDateTime.getMinutes().toString().padStart(2, '0')}:00`;

    try {
        // First, check for conflicts with the updated data
        const conflicts = await checkForConflicts({
            event_date: eventDate,
            start_time: startTime,
            end_time: endTime,
            location: location
        });
        
        if (conflicts.length > 0) {
            showEditConflictOptions(conflicts, {
                event: {
                    title: title,
                    event_date: eventDate,
                    start_time: startTime,
                    event_type_id: eventTypeId,
                    location: location,
                    end_time: endTime
                },
                bulletins: bulletins
            });
            return;
        }
        
        // If no conflicts, proceed with update
        const response = await authFetch(`${API_BASE}/events/${eventId}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                event: {
                    title: title,
                    event_date: eventDate,
                    start_time: startTime,
                    event_type_id: eventTypeId,
                    location: location,
                    end_time: endTime
                },
                bulletins: bulletins
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}`);
        }

        showMessage("Event and bulletins updated successfully!");
        setTimeout(() => window.location.href = "view_plans.html", 2000);
    } catch (error) {
        console.error("Update error:", error);
        showError(`Failed to update: ${error.message}`);
        
        // If it's an authentication error, redirect to login
        if (error.message.includes('Token') || error.message.includes('auth')) {
            window.location.href = 'login.html';
        }
    }
}

function showEditConflictOptions(conflicts, eventData) {
    const modal = document.getElementById('conflictModal');
    const body = document.getElementById('conflictModalBody');
    body.innerHTML = '<h2>Conflicting Events Detected</h2>';
    body.innerHTML += '<p>Events in the same location cannot overlap. Please resolve the conflict:</p>';
    
    conflicts.forEach(conflict => {
        const conflictDiv = document.createElement('div');
        conflictDiv.className = 'conflict-item';
        conflictDiv.innerHTML = `
            <strong>${conflict.title}</strong><br>
            Date: ${conflict.event_date}<br>
            Time: ${conflict.start_time} - ${conflict.end_time}<br>
            Location: ${conflict.location || 'Unassigned Room'}
        `;
        body.appendChild(conflictDiv);
    });

    // Clear existing buttons
    const optionsDiv = modal.querySelector('.conflict-options');
    optionsDiv.innerHTML = '';

    // Option: Change My Event Time
    const changeMineBtn = document.createElement('button');
    changeMineBtn.className = 'btn btn-warning';
    changeMineBtn.innerHTML = '<i class="fas fa-clock"></i> Change My Event Time';
    changeMineBtn.onclick = () => {
        modal.style.display = 'none';
        showMessage("Please adjust your event time or location and try again.", "info");
    };

    // Option: Change My Event Location
    const changeLocationBtn = document.createElement('button');
    changeLocationBtn.className = 'btn btn-info';
    changeLocationBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Change My Event Location';
    changeLocationBtn.onclick = () => {
        modal.style.display = 'none';
        showMessage("Please select a different location and try again.", "info");
    };

    // Option: Keep My Event (Delete Conflicting)
    const keepMineBtn = document.createElement('button');
    keepMineBtn.className = 'btn btn-danger';
    keepMineBtn.innerHTML = '<i class="fas fa-trash"></i> Keep My Event (Delete Conflicting)';
    keepMineBtn.onclick = async () => {
        try {
            for (const conflict of conflicts) {
                await apiCall(`${API_BASE}/events/${conflict.id}`, { method: "DELETE" });
            }
            modal.style.display = 'none';
            // Retry saving with the original data
            await saveEventWithConflictResolution(eventData);
        } catch (error) {
            showError(`Failed to delete conflicting event: ${error.message}`);
        }
    };

    // Add buttons to options div
    optionsDiv.appendChild(changeMineBtn);
    optionsDiv.appendChild(changeLocationBtn);
    optionsDiv.appendChild(keepMineBtn);
    
    modal.style.display = 'block';
}

async function saveEventWithConflictResolution(eventData) {
    try {
        const response = await authFetch(`${API_BASE}/events/${eventId}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                event: eventData.event,
                bulletins: eventData.bulletins
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}`);
        }

        showMessage("Event and bulletins updated successfully!");
        setTimeout(() => window.location.href = "view_plans.html", 2000);
    } catch (error) {
        console.error("Update error:", error);
        showError(`Failed to update: ${error.message}`);
    }
}

// Add endpoint to check for conflicts
async function checkConflict(eventDate, startTime, endTime, location, excludeId = null) {
    try {
        const data = {
            event_date: eventDate,
            start_time: startTime,
            end_time: endTime,
            location: location
        };
        
        if (excludeId) {
            data.exclude_event_id = excludeId;
        }
        
        const response = await authFetch(`${API_BASE}/events/check-conflict`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            throw new Error("Failed to check conflicts");
        }
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error("Error checking conflicts:", error);
        return { has_conflict: false, conflicts: [] };
    }
}

            // Mobile menu toggle
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.getElementById('sidebar');
            
            menuToggle.addEventListener('click', () => {
                sidebar.classList.toggle('active');
            });

            // Close sidebar when clicking outside on mobile
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768 && 
                    !sidebar.contains(e.target) && 
                    e.target !== menuToggle) {
                    sidebar.classList.remove('active');
                }
            });
    window.updateItem = updateItem;
    window.deleteBulletinItem = deleteBulletinItem;
    window.addBulletinItem = addBulletinItem;
    window.submitEdit = submitEdit;

    document.addEventListener('DOMContentLoaded', loadEventAndBulletins);
  </script>
</body>
</html>